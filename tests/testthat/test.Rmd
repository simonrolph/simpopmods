---
title: "IPM Descriptor Object - test_IPM"
output: html_document
---

## States and kernels

Here we need to define the different discrete states and whether there is a continious size state within these discrete states. For example if we want to model a plant population we might have three discrete states: 'seed', 'immature' and 'mature'. This IPM discriptor format is limited to one continious size domain. For these three discrete size classes immature and mature plants also have a continious size state. Therefore we would have `states <- c('seed','immature','mature')` and `states_z <- c('F','T','T')`.

In order to differentiate different demographic processes, such as reproduction and growth/survival we put them into different kernels. For example we might use `kernels <- c('P','Fec','Clo')` where `P` is the growth/survival kernel, `Fec` is the sexual reproduction kernel and `Clo` is a kernel describing clonal reproduction

```{r}
states <- c("seed", "immature", "mature")
states_z <- c("FALSE", "TRUE", "TRUE")
kernels <- c("Fec", "P", "Clo")
```

## Parameter information

```{r}
par_info <- data.frame(t(data.frame(
   param_1  =  c(par = "param_1",min = -Inf,max = Inf,samp = T),
   param_2  =  c(par = "param_2",min = -Inf,max = Inf,samp = T),
   param_3  =  c(par = "param_3",min = -Inf,max = Inf,samp = T),
   param_4  =  c(par = "param_4",min = -Inf,max = Inf,samp = T),
   param_5  =  c(par = "param_5",min = -Inf,max = Inf,samp = T),
   param_6  =  c(par = "param_6",min = -Inf,max = Inf,samp = T),
   param_7  =  c(par = "param_7",min = -Inf,max = Inf,samp = T),
   param_8  =  c(par = "param_8",min = -Inf,max = Inf,samp = T),
   param_9  =  c(par = "param_9",min = -Inf,max = Inf,samp = T),
   param_10  =  c(par = "param_10",min = -Inf,max = Inf,samp = T)
)),stringsAsFactors=F)

par_info$min <- as.numeric(par_info$min);par_info$max <- as.numeric(par_info$max)

par_fns <- list(
#    param_1  = function(params){0},
#    param_2  = function(params){0},
#    param_3  = function(params){0},
#    param_4  = function(params){0},
#    param_5  = function(params){0},
#    param_6  = function(params){0},
#    param_7  = function(params){0},
#    param_8  = function(params){0},
#    param_9  = function(params){0},
#    param_10  = function(params){0}
)
```

## Demographic functions


```{r}
demo_fns <- list(
  demo_fn1= function(z1, z, params){
    #insert function here
    return()
  },
  demo_fn2= function(z1, z, params){
    #insert function here
    return()
  }
)
```

## Kernel functions

```{r}
kernel_fns <- init_nested_list(kernels,states)

### KERNEL: Fec
# seed -> seed
kernel_fns$Fec$seed$seed <- function (z1, z, params) {
   return()
}

# seed -> immature
kernel_fns$Fec$immature$seed <- function (z1, z, params) {
   return()
}

# seed -> mature
kernel_fns$Fec$mature$seed <- function (z1, z, params) {
   return()
}

# immature -> seed
kernel_fns$Fec$seed$immature <- function (z1, z, params) {
   return()
}

# immature -> immature
kernel_fns$Fec$immature$immature <- function (z1, z, params) {
   return()
}

# immature -> mature
kernel_fns$Fec$mature$immature <- function (z1, z, params) {
   return()
}

# mature -> seed
kernel_fns$Fec$seed$mature <- function (z1, z, params) {
   return()
}

# mature -> immature
kernel_fns$Fec$immature$mature <- function (z1, z, params) {
   return()
}

# mature -> mature
kernel_fns$Fec$mature$mature <- function (z1, z, params) {
   return()
}


### KERNEL: P
# seed -> seed
kernel_fns$P$seed$seed <- function (z1, z, params) {
   return()
}

# seed -> immature
kernel_fns$P$immature$seed <- function (z1, z, params) {
   return()
}

# seed -> mature
kernel_fns$P$mature$seed <- function (z1, z, params) {
   return()
}

# immature -> seed
kernel_fns$P$seed$immature <- function (z1, z, params) {
   return()
}

# immature -> immature
kernel_fns$P$immature$immature <- function (z1, z, params) {
   return()
}

# immature -> mature
kernel_fns$P$mature$immature <- function (z1, z, params) {
   return()
}

# mature -> seed
kernel_fns$P$seed$mature <- function (z1, z, params) {
   return()
}

# mature -> immature
kernel_fns$P$immature$mature <- function (z1, z, params) {
   return()
}

# mature -> mature
kernel_fns$P$mature$mature <- function (z1, z, params) {
   return()
}


### KERNEL: Clo
# seed -> seed
kernel_fns$Clo$seed$seed <- function (z1, z, params) {
   return()
}

# seed -> immature
kernel_fns$Clo$immature$seed <- function (z1, z, params) {
   return()
}

# seed -> mature
kernel_fns$Clo$mature$seed <- function (z1, z, params) {
   return()
}

# immature -> seed
kernel_fns$Clo$seed$immature <- function (z1, z, params) {
   return()
}

# immature -> immature
kernel_fns$Clo$immature$immature <- function (z1, z, params) {
   return()
}

# immature -> mature
kernel_fns$Clo$mature$immature <- function (z1, z, params) {
   return()
}

# mature -> seed
kernel_fns$Clo$seed$mature <- function (z1, z, params) {
   return()
}

# mature -> immature
kernel_fns$Clo$immature$mature <- function (z1, z, params) {
   return()
}

# mature -> mature
kernel_fns$Clo$mature$mature <- function (z1, z, params) {
   return()
}

```
## Kernel size limit functions

```{r}
# lower size limit
limit_lower <- function(params,
test_IPM
){
  
  return()
}

#upper size limit
limit_upper <- function(params,
test_IPM
){
  
  return()
}

# function to determine the resolution of the kernel
kernel_res <- function(params,
test_IPM
){
  
  return()
}
```

## Create IPM descriptor object

```{r}
test_IPM<- list(
  states = states,
  states_z = states_z,
  kernels = kernels,
  par_info = par_info,
  par_fns = par_fns,
  demo_fns = demo_fns,
  kernel_fns = kernel_fns,
  limit_lower = limit_lower,
  limit_upper = limit_upper,
  kernel_res = kernel_res
)

class(test_IPM) <- append(class(test_IPM),'IPM_descriptor')

# Save the IPM descriptor object
save(test_IPM,file = stop("'file' must be specified"))
```
