### IPM descriptor object

```{r, echo = F}
rm(list = ls())

# $demo_fns
demo_fns <- list(
  ## G_z1z -  Growth function, given you are size z now returns the pdf of size z1 next time
  grow = function(z1, z, params) {
    mu <-
      params["grow.int"] + params["grow.z"] * z           # mean size next year
    sig <-
      params["grow.sd"]                                 # sd about mean
    p.den.grow <-
      dnorm(z1, mean = mu, sd = sig)             # pdf that you are size z1 given you were size z
    return(p.den.grow)
  },
  ## s_z Survival function, logistic regression
  surv = function(z, params) {
    linear.p <-
      params["surv.int"] + params["surv.z"] * z  # linear predictor
    #p <- (1/(1+exp(-linear.p))) # logistic transformation to probability with no cap
    p <-
      pmin(1 / (1 + exp(-linear.p)), rep(0.99, length(z))) # logistic transformation to probability with constant cap
    #p <- min((1/(1+exp(-linear.p))),params["surv.cap"]) # logistic transformation to probability with cut-off cap
    #p <- (1/(1+exp(-linear.p)))*params["surv.cap"] # logistic transformation to probability with scalar cap
    return(p)
  },
  ## p_bz Probability of flowering function, logistic regression
  flow = function(z, params) {
    linear.p <-
      params["flow.int"] + params["flow.z"] * z      # linear predictor
    p <-
      1 / (1 + exp(-linear.p))                                # logistic transformation to probability
    return(p)
  },
  ## b_z Seed production function
  seed = function(z, params) {
    #if (params["seed.int"] < 0) {params["seed.int"] <- params["seed.int"] * params["seed.z"]}
    N <-
      exp(params["seed.int"] + params["seed.z"] * z)   # seed production of a size z plant
    return(N)
  },
  ## c_0z1 Recruit size pdf
  rcsz = function(z1, params) {
    mu <- params["rcsz.int"]
    sig <- params["rcsz.sd"]
    p.deRecr <-
      dnorm(z1, mean = mu, sd = sig)              # pdf of a size z1 recruit
    return(p.deRecr)
  },
  #maturity
  matu = function(z,params) {
    linear.p <-
      params["matu.int"] + params["matu.z"] * z      # linear predictor
    p <-
      1 / (1 + exp(-linear.p))                                # logistic transformation to probability
    return(p)
  }
)

# IPM_desc object
IPM_desc <- list(
  demo_fns = demo_fns
)

```

Kernel functions

```{r, echo = F}

# survival kernels

# immature to immature
P_z1z_imm_to_imm = function (z1, z, params) {
  # survival * growth * not maturing
  return(IPM_desc$demo_fns$surv(z, params) * IPM_desc$demo_fns$grow(z1, z, params) * (1-IPM_desc$demo_fns$matu(z1, params)) )
}

# immature to mature
P_z1z_imm_to_mat = function (z1, z, params) {
  # survival *  growth * maturing
  return(IPM_desc$demo_fns$surv(z, params) * IPM_desc$demo_fns$grow(z1, z, params) * IPM_desc$demo_fns$matu(z1, params))
}

# mature to mature
P_z1z_mat_to_mat = function (z1, z, params) {
  # survival * growth
  return(IPM_desc$demo_fns$surv(z, params) * IPM_desc$demo_fns$grow(z1, z, params))
}

### FECUNDITY

## Define the fecundity kernels
F_z1z_mat_to_imm = function (z1, z, params) {
  # survival * flowering * number of seeds * recruit survival * recruit size * not maturing
  return(
    IPM_desc$demo_fns$flow(z, params) * IPM_desc$demo_fns$seed(z, params) * params["p.r"] * IPM_desc$demo_fns$rcsz(z1, params) * (1-IPM_desc$demo_fns$matu(z1, params))
  )
}

F_z1z_mat_to_mat = function (z1, z, params) {
  # survival * flowering * number of seeds * recruit survival * recruit size * maturity
  return(
    IPM_desc$demo_fns$flow(z, params) * IPM_desc$demo_fns$seed(z, params) * params["p.r"] * IPM_desc$demo_fns$rcsz(z1, params) * IPM_desc$demo_fns$matu(z1, params)
  )
}

```

Full parameter set

```{r, echo = F}

params <- c(
  surv.int  =  0.1,
  surv.z    =   0.3,
  flow.int  = 0.1,
  flow.z    =   0.2,
  grow.int  =   0.27,
  grow.z    =   1 - 0.27,
  grow.sd   =   0.38,
  rcsz.int  =   0,
  rcsz.sd   =   0.2,
  seed.int  =   1,
  seed.z    =   0,
  p.r       =   1,
  matu.int  =  0,
  matu.z    = 0.3
)

```

Domeig function
```{r, echo = F}
# produce ssd from parameter set and IPM_desc
calc_dom_eig <- function(A, tol = 1e-8) {
  qmax <- 10 * tol
  lam <- 1
  x <- rep(1, nrow(A))

  while (qmax > tol) {
    x1 <- A %*% x
    qmax <- sum(abs(x1 - lam * x))
    lam <- sum(x1)
    x <- x1 / lam
  }

  # Having found w (within tol), get lambda
  x1 <- A %*% x
  lam <- sum(x1)
  x <- x1 / lam
  return(list(lambda = lam, w = x / sum(x)))
}

```


# Make the IPM

```{r, echo = F}

#### example
meshpts <- seq(from = -2, to = 3.5, by = 0.005)



mesh_len <- length(meshpts)

dlta <- meshpts[2] - meshpts[1]
lwr <- min(meshpts) - dlta / 2
upr <- max(meshpts) + dlta / 2

P_kern <- F_kern <- matrix(0, nrow = mesh_len*2,ncol = mesh_len*2)

#make each of the parts of the kernel
P_kern_imm_to_imm <- outer(meshpts, meshpts, P_z1z_imm_to_imm,params) * dlta
P_kern_imm_to_mat <- outer(meshpts, meshpts, P_z1z_imm_to_mat,params) * dlta
P_kern_mat_to_mat <- outer(meshpts, meshpts, P_z1z_mat_to_mat,params) * dlta

# put them in the big kernel
P_kern[1:mesh_len,1:mesh_len] <- P_kern_imm_to_imm
P_kern[(mesh_len+1):(mesh_len*2),1:mesh_len] <- P_kern_imm_to_mat
P_kern[(mesh_len+1):(mesh_len*2),(mesh_len+1):(mesh_len*2)] <- P_kern_mat_to_mat

#image(t(P_kern))

F_kern_mat_to_imm <- outer(meshpts, meshpts, F_z1z_mat_to_imm, params) * dlta
F_kern_mat_to_mat <- outer(meshpts, meshpts, F_z1z_mat_to_mat, params) * dlta

F_kern[1:mesh_len,(mesh_len+1):(mesh_len*2)] <- F_kern_mat_to_imm
F_kern[(mesh_len+1):(mesh_len*2),(mesh_len+1):(mesh_len*2)] <- F_kern_mat_to_mat

#image(t(F_kern))

K_kern <- P_kern+F_kern

# calcualte lambda
lambda.IPM <- calc_dom_eig(K_kern)$lambda

```

# make the MPM

## step 1

Make ssd approximation functions for:
 * SSD of immature and mature summed together
 * SSD of just immature
 * SSD of mature

```{r, echo = F}

ssd <- calc_dom_eig(K_kern)$w

ssd_all <- ssd[1:mesh_len] + ssd[(mesh_len+1):(mesh_len*2)]

ssd_imm <- ssd[1:mesh_len]
#ssd_imm <- ssd_imm/sum(ssd_imm)

ssd_mat <- ssd[(mesh_len+1):(mesh_len*2)]
#ssd_mat <- ssd_mat/sum(ssd_mat)



# approximation to the size distribition function
n_t <- approxfun(meshpts, ssd_all, rule = 2)
n_t_imm <- approxfun(meshpts, ssd_imm, rule = 2)
n_t_mat <- approxfun(meshpts, ssd_mat, rule = 2)

#n_t_imm <- n_t_mat <- n_t

plot(meshpts,ssd_all)


```

## step 2
PREPARE TO BE INTEGRATED
extract the IPM functions we'll use

```{r, echo = F}

# make a function to compute integration stuff
mk_meshpts <- function (l, u, m) {
  h <- (u - l) / m
  meshpts <- l + ((1:m) - 1 / 2) * h
  list(
    m = m,
    h = h,
    l = l,
    u = u,
    meshpts = meshpts
  )
}

mesh_res <- 250

# normal survival with any maturity faff
s_z <- IPM_desc$demo_fns$surv

# growth
g_z <- IPM_desc$demo_fns$grow

#maturity
m_z <- IPM_desc$demo_fns$matu

# fecundity mature to immature (not maturing in first year)
f_z_to_imm <- F_z1z_mat_to_imm

# fecundity mature to mature (maturing in first year)
f_z_to_mat <- F_z1z_mat_to_mat

```

## step 3
Find the stage boundaries

```{r, echo = F}

# approximation to the cumulative density function
cum_dist_n_t <- approxfun(meshpts, cumsum(ssd_all) / sum(ssd_all))

n_state_mpm <- 12 # how many classes do I want to make my MPM with?
qtiles <- seq(0, 1, length.out = n_state_mpm + 1)
qtiles <- qtiles[-c(1, length(qtiles))]

fun <- function(x, which) {
  cum_dist_n_t(x) - which
}

stage_boundaries <- qtiles
for (i in seq_along(qtiles)) {
  stage_boundaries[i] <-
    uniroot(fun, interval = range(meshpts),  which =  qtiles[i])$root
}
stage_boundaries <- c(lwr, stage_boundaries, upr)

```

## Step 4 Survival/growth kernels

```{r, echo = F}

### immature to immature ### ---------------------------

# first part
P_imm_to_imm <- matrix(0,nrow = n_state_mpm, ncol = n_state_mpm)
for (i in seq_len(n_state_mpm)) {
  sub_mesh_i <-
    mk_meshpts(stage_boundaries[i], stage_boundaries[i + 1], mesh_res)
  mpts_now_i <- sub_mesh_i$meshpts
  for (j in seq_len(n_state_mpm)) {
    sub_mesh_j <- mk_meshpts(stage_boundaries[j], stage_boundaries[j + 1], mesh_res)
    mpts_now_j <- sub_mesh_j$meshpts

    #growth (ignoring survival)
    g_now <- outer(mpts_now_i, mpts_now_j, g_z, params = params)
    
    # survival
    s_now <- s_z(mpts_now_j, params = params)
    
    #maturity 
    m_now <- 1-m_z(mpts_now_i, params = params)
    
    # ssd
    n_t_now <- n_t_imm(mpts_now_j)

    # put it together
    P_imm_to_imm[i, j] <- sum(g_now %*% (s_now * m_now * n_t_now)) / sum(n_t_now)
    P_imm_to_imm[i, j] <- P_imm_to_imm[i, j] * sub_mesh_i$h
  }
}


# immature to mature ### ---------------------------

# first part
P_imm_to_mat  <- matrix(0,nrow = n_state_mpm, ncol = n_state_mpm)
for (i in seq_len(n_state_mpm)) {
  sub_mesh_i <-
    mk_meshpts(stage_boundaries[i], stage_boundaries[i + 1], mesh_res)
  mpts_now_i <- sub_mesh_i$meshpts
  for (j in seq_len(n_state_mpm)) {
    sub_mesh_j <- mk_meshpts(stage_boundaries[j], stage_boundaries[j + 1], mesh_res)
    mpts_now_j <- sub_mesh_j$meshpts

    #growth
    g_now <- outer(mpts_now_i, mpts_now_j, g_z, params = params)
    
    # survival
    s_now <- s_z(mpts_now_j, params = params)
    
    m_now <- m_z(mpts_now_i, params = params)
    
    # ssd
    n_t_now <- n_t_imm(mpts_now_j)

    # put it together
    P_imm_to_mat[i, j] <- sum(g_now %*% (s_now * m_now * n_t_now)) / sum(n_t_now)
    P_imm_to_mat[i, j] <- P_imm_to_mat[i, j] * sub_mesh_i$h
  }
}


### mature to mature ### ---------------------------

# first part
P_mat_to_mat <- matrix(0,nrow = n_state_mpm, ncol = n_state_mpm)
for (i in seq_len(n_state_mpm)) {
  sub_mesh_i <-
    mk_meshpts(stage_boundaries[i], stage_boundaries[i + 1], mesh_res)
  mpts_now_i <- sub_mesh_i$meshpts
  for (j in seq_len(n_state_mpm)) {
    sub_mesh_j <- mk_meshpts(stage_boundaries[j], stage_boundaries[j + 1], mesh_res)
    mpts_now_j <- sub_mesh_j$meshpts

    #growth
    g_now <- outer(mpts_now_i, mpts_now_j, g_z, params = params)
    
    # survival
    s_now <- s_z(mpts_now_j, params = params)
    

    # ssd
    n_t_now <- n_t_mat(mpts_now_j)
    
    #put it together
    P_mat_to_mat[i, j] <- sum(g_now %*% (s_now * n_t_now)) / sum(n_t_now)
    P_mat_to_mat[i, j] <- P_mat_to_mat[i, j] * sub_mesh_i$h
  }
}


```

## Step 5 fecundity kernels

```{r, echo = F}

# mature to immature ---------------------
F_mat_to_imm <- matrix(0,nrow = n_state_mpm, ncol = n_state_mpm)

for (i in seq_len(n_state_mpm)) {

  sub_mesh_i <- mk_meshpts(stage_boundaries[i], stage_boundaries[i + 1], mesh_res)
  mpts_now_i <- sub_mesh_i$meshpts

  for (j in seq_len(n_state_mpm)) {

    sub_mesh_j <- mk_meshpts(stage_boundaries[j], stage_boundaries[j + 1], mesh_res)
    mpts_now_j <- sub_mesh_j$meshpts

    #fecundity
    f_now <- outer(mpts_now_i, mpts_now_j, f_z_to_imm, params = params)
    
    #ssd
    n_t_now <- n_t_mat(mpts_now_j)
    
    F_mat_to_imm [i, j] <- sum(f_now %*% n_t_now) / sum(n_t_now)
    F_mat_to_imm [i, j] <- F_mat_to_imm[i, j] * sub_mesh_i$h

  }
}

# mature to mature -----------------------
F_mat_to_mat <- matrix(0,nrow = n_state_mpm, ncol = n_state_mpm)
for (i in seq_len(n_state_mpm)) {

  sub_mesh_i <- mk_meshpts(stage_boundaries[i], stage_boundaries[i + 1], mesh_res)
  mpts_now_i <- sub_mesh_i$meshpts

  for (j in seq_len(n_state_mpm)) {

    sub_mesh_j <- mk_meshpts(stage_boundaries[j], stage_boundaries[j + 1], mesh_res)
    mpts_now_j <- sub_mesh_j$meshpts

    #fecundity
    f_now <- outer(mpts_now_i, mpts_now_j, f_z_to_mat, params = params)
    
    #ssd
    n_t_now <- n_t_mat(mpts_now_j)
    
    F_mat_to_mat[i, j] <- sum(f_now %*% n_t_now) / sum(n_t_now)
    F_mat_to_mat[i, j] <- F_mat_to_mat[i, j] * sub_mesh_i$h

  }
}

```



## Step 6:  put matrices together and test

```{r, echo = F}

# make blank big matrices
P_matrix <- F_matrix <- matrix(0,nrow = n_state_mpm*2, ncol = n_state_mpm*2)

#compile survival/growth
P_matrix[1:n_state_mpm,1:n_state_mpm] <- P_imm_to_imm
P_matrix[(n_state_mpm+1):(n_state_mpm*2),1:n_state_mpm] <- P_imm_to_mat
P_matrix[(n_state_mpm+1):(n_state_mpm*2),(n_state_mpm+1):(n_state_mpm*2)] <- P_mat_to_mat

#image(t(P_kern))
image(t(P_matrix),main = "Growth/survival matrix")

#compile fecundity
F_matrix[1:n_state_mpm,(n_state_mpm+1):(n_state_mpm*2)] <- F_mat_to_imm
F_matrix[(n_state_mpm+1):(n_state_mpm*2),(n_state_mpm+1):(n_state_mpm*2)] <- F_mat_to_mat

#image(t(F_kern))
image(t(F_matrix),main = "Fecundity matrix")

#make full matirx
K_matrix <- P_matrix + F_matrix

# calculate lambda
lambda.MPM <- calc_dom_eig(K_matrix)$lambda

#compare
print(paste("IPM lambda:",lambda.IPM))
print(paste("MPM lambda:",lambda.MPM))
print(paste("error: ",abs(lambda.IPM-lambda.MPM)))
print(paste("error %: ",abs(lambda.IPM-lambda.MPM)/lambda.IPM*100))
if (abs(lambda.IPM-lambda.MPM) <0.01) {
  print("it works! (within error margin of 0.01)")
} else {
  print("it doesn't work yet :(")
}

ssd_matrix <- calc_dom_eig(K_matrix)$w

ssd_matrix_all <- ssd_matrix[1:n_state_mpm]+ssd_matrix[(n_state_mpm+1):(n_state_mpm*2)]
abs(ssd_matrix_all-(1/n_state_mpm))


```









